<div class="blog">
    <h3>结构型模式(Structural Pattern)之桥接模式(Bridge Pattern)</h3>
    <p>
    桥接模式可以理解为两岸中间的一座桥。把程序的世界就理解为现实的世界是一样的，现实中很多地方需要桥，而程序中亦是如此。
    个人认为<a href="http://blog.csdn.net/lovelion/article/details/7464195">这里</a>讲的不错。
    </p>
    <pre>
    定义:将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。
    </pre>
    <img src="http://img.my.csdn.net/uploads/201204/16/1334505919_5277.gif">

    <h5>举例:以钢笔为例，当我们需要用钢笔绘画时，需要笔尖粗细的不同，以及笔墨颜色的不同。这里我们使用桥接模式，能支持良好的扩容以及解耦。</h5>
    <pre>
    public interface IColor {
        void bepaint(String typePen);
    }
    public class GreenColor implements IColor{
        @Override
        public void bepaint(String typePen) {
            System.out.println("type="+typePen+",colorName=green");
        }
    }
    public class RedColor implements IColor{
        @Override
        public void bepaint(String typePen) {
            System.out.println("type="+typePen+",colorName=red");
        }
    }
    //other implement class

    public abstract class Pen {
        protected IColor ic ;
        public void setColor(IColor ic){
            this.ic = ic;
        }

        abstract void draw();
    }
    public class BigPen extends Pen{
        @Override
        void draw() {
            ic.bepaint("bigPen");
        }
    }
    public class SmallPen extends Pen{
        @Override
        void draw() {
            ic.bepaint("smallPen");
        }
    }
    //other extends class eq:middlePen

    //test
    IColor ic = new GreenColor();
	Pen p = new SmallPen();
	p.setColor(ic);
	p.draw();
   //out:type=smallPen,colorName=green

    注:1实际开发时使用XML+Java反射技术实现动态创建对象，如果在扩展颜色或者钢笔种类时，只需修改XML文件即可。
       2扩展对象时可以直接创建新的即可，不需要修改原来程序，从而实现了良好的"开闭"原则。
    </pre>
    <h5>总结:</h5>
    <pre>
    优点:
        (1)分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。
        (2)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。
        (3)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。

    缺点:
        (1)桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。
        (2)桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。

    适用场景:
        (1)如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。
        (2)“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
        (3)一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。
        (4)对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。
    </pre>

    <a href="http://blog.csdn.net/lovelion/article/details/17517213">参考</a>

    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="Michael-Bridge" data-title="Bridge" data-url="http://michaelygzhang.github.io/home/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"michaelygzhang"};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0]
            || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>